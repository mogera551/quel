const e="*",t="dot-notation",a={directlyGet:Symbol.for(t+".direct_get"),directlySet:Symbol.for(t+".direct_set"),isSupportDotNotation:Symbol.for(t+".is_support_dot_notation")},s=new RegExp(/^\$([0-9]+)$/);class r{#e;get name(){return this.#e}#t;get pathNames(){return this.#t}#a;get parentPathNames(){return this.#a}#s;get parentPath(){return this.#s}#r;get parentPaths(){return this.#r}#n;get setOfParentPaths(){return this.#n}#i;get lastPathName(){return this.#i}#h;get regexp(){return this.#h}#p;get level(){return this.#p}#l;get isPrimitive(){return this.#l}#o;get nearestWildcardName(){return this.#o}#c;get nearestWildcardParentName(){return this.#c}constructor(t){if(this.#e=t,this.#t=t.split("."),this.#a=this.#t.slice(0,-1),this.#r=this.#a.reduce(((e,t)=>(e.push(e.at(-1)?.concat(t)??[t]),e)),[]).map((e=>e.join("."))),this.#n=new Set(this.#r),this.#s=this.#a.join("."),this.#i=this.#t.at(-1),this.#h=new RegExp("^"+t.replaceAll(".","\\.").replaceAll("*","([0-9a-zA-Z_]*)")+"$"),this.#p=this.#t.reduce(((t,a)=>t+(a===e?1:0)),0),this.#l=1===this.#t.length,this.#o=void 0,this.#c=void 0,this.#p>0)for(let t=this.#t.length-1;t>=0;t--)if(this.#t[t]===e){this.#o=this.#t.slice(0,t+1).join("."),this.#c=this.#t.slice(0,t).join(".");break}}static create(e){const t=this.propertyNameByName.get(e);if(void 0!==t)return t;const a=new r(e);return this.propertyNameByName.set(e,a),a}static propertyNameByName=new Map;static parse(e){const t=[],a=[];for(const s of e.split(".")){const e=Number(s);isNaN(e)?a.push(s):(t.push(e),a.push("*"))}return{propName:r.create(a.join(".")),indexes:t}}}class n{#m=[];#d=new Map;get lastIndexes(){return this.#m[this.#m.length-1]}get stackIndexes(){return this.#m}get matchByName(){return this.#d}getByPropertyName(t,{propName:a},s){let n;if(Reflect.has(t,a.name))n=Reflect.get(t,a.name,s);else if(""!==a.parentPath){const i=r.create(a.parentPath),h=this.getByPropertyName(t,{propName:i},s);if(void 0!==h){const t=a.lastPathName===e?this.lastIndexes[a.level-1]:a.lastPathName;n=Reflect.get(h,t)}}return n}setByPropertyName(t,{propName:a,value:s},n){let i=!1;if(Reflect.has(t,a.name)||a.isPrimitive)i=Reflect.set(t,a.name,s,n);else{const h=r.create(a.parentPath),p=this.getByPropertyName(t,{propName:h},n);if(void 0!==p){const t=a.lastPathName===e?this.lastIndexes[a.level-1]:a.lastPathName;i=Reflect.set(p,t,s)}}return i}pushIndexes(e,t){this.#m.push(e);try{return Reflect.apply(t,this,[])}finally{this.#m.pop()}}getFunc=(e,t)=>({propName:a,indexes:s})=>this.pushIndexes(s,(()=>this.getByPropertyName(e,{propName:a},t)));setFunc=(e,t)=>({propName:a,indexes:s},r)=>this.pushIndexes(s,(()=>this.setByPropertyName(e,{propName:a,value:r},t)));getExpandLastLevel(e,{propName:t,indexes:a},s){const n=this.getFunc(e,s);if(void 0===t.nearestWildcardName)throw new Error(`not found wildcard path of '${t.name}'`);const i=r.create(t.nearestWildcardParentName);return n({propName:i,indexes:a}).map(((e,s)=>n({propName:t,indexes:a.concat(s)})))}setExpandLastLevel(e,{propName:t,indexes:a,values:s},n){const i=this.getFunc(e,n),h=this.setFunc(e,n);if(void 0===t.nearestWildcardName)throw new Error(`not found wildcard path of '${t.name}'`);const p=r.create(t.nearestWildcardParentName),l=i({propName:p,indexes:a}),o=Array.isArray(s)?s:[...Array(l.length)].map((e=>s));if(t.nearestWildcardName===t.name)h({propName:p,indexes:a},o);else{if(o.length!==l.length)throw new Error(`not match array count '${t.name}'`);for(let e in l)h({propName:t,indexes:a.concat(Number(e))},o[e])}return!0}directlyGet(e,{prop:t,indexes:a},s){const n=r.create(t);return this.pushIndexes(a,(()=>this.getByPropertyName(e,{propName:n},s)))}directlySet(e,{prop:t,indexes:a,value:s},n){const i=r.create(t);return this.pushIndexes(a,(()=>this.setByPropertyName(e,{propName:i,value:s},n)))}get(e,t,n){const i="string"==typeof t;if(i&&(t.startsWith("@@__")||"constructor"===t))return Reflect.get(e,t,n);const h=this.getFunc(e,n),p=this.lastIndexes;let l;if(t===a.directlyGet)return(t,a)=>Reflect.apply(this.directlyGet,this,[e,{prop:t,indexes:a},n]);if(t===a.directlySet)return(t,a,s)=>Reflect.apply(this.directlySet,this,[e,{prop:t,indexes:a,value:s},n]);if(t===a.isSupportDotNotation)return!0;if(i){if(l=s.exec(t))return p?.[Number(l[1])-1]??void 0;if("@"===t.at(0)){const a=t.slice(1),s=r.create(a);if((p?.length??0)+1<s.level)throw new Error("array level not match");const i=p?.slice(0,s.level-1)??[];return this.getExpandLastLevel(e,{propName:s,indexes:i},n)}if(this.#d.has(t))return h(this.#d.get(t));const a=r.parse(t);return a.propName.level===a.indexes.length?(this.#d.set(t,a),h(a)):h({propName:a.propName,indexes:a.indexes.concat(p?.slice(a.indexes.length)??[])})}return Reflect.get(e,t,n)}set(e,t,a,s){if("string"==typeof t){if(t.startsWith("@@__")||"constructor"===t)return Reflect.set(e,t,a,s);const n=this.setFunc(e,s),i=this.lastIndexes;if("@"===t.at(0)){const n=t.slice(1),i=r.create(n);if((this.lastIndexes?.length??0)+1<i.level)throw new Error("array level not match");const h=this.lastIndexes?.slice(0,i.level-1)??[];return this.setExpandLastLevel(e,{propName:i,indexes:h,values:a},s)}if(this.#d.has(t))return n(this.#d.get(t),a);const h=r.parse(t);return h.propName.level===h.indexes.length?(this.#d.set(t,h),n(h,a)):n({propName:h.propName,indexes:h.indexes.concat(i?.slice(h.indexes.length)??[])},a)}return Reflect.set(e,t,a,s)}}export{n as Handler,r as PropertyName,s as RE_CONTEXT_INDEX,a as Symbols};
